generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String        @id @default(uuid())
  email           String        @unique
  username        String        @unique
  passwordHash    String
  role            String        @default("user") // "user" or "admin"
  geminiApiKey    String?       @db.Text  // Encrypted Gemini API token

  // Relations
  characters      Character[]
  gameSessions    GameSession[]
  geminiUsage     GeminiUsage[]
  adminActions    AdminAuditLog[] @relation("AdminActions")
  bugReports      BugReport[]
  assignedBugReports BugReport[] @relation("BugReportAssignee")
  resolvedBugReports BugReport[] @relation("BugReportResolver")

  // Meta
  isActive        Boolean       @default(true)
  lastLoginAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([email])
  @@index([username])
}

model Character {
  id        String   @id @default(uuid())
  name      String
  race      String
  class     String
  level     Int      @default(1)

  // Stats
  strength      Int
  dexterity     Int
  constitution  Int
  intelligence  Int
  wisdom        Int
  charisma      Int

  // Combat
  hitPoints       Int
  maxHitPoints    Int
  armorClass      Int

  // Meta
  experience      Int      @default(0)
  avatarUrl       String?
  background      String?  @db.Text

  // ASI (Ability Score Improvement) System
  pendingASI      Boolean  @default(false)  // Má hráč nevyužité ASI?
  asiHistory      Json     @default("[]")   // Historie ASI: [{level: 4, changes: {strength: 1, dexterity: 1}}]

  // User ownership
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  gameSessions    GameSession[]
  inventory       Item[]
  spellSlots      SpellSlot[]      @relation("CharacterSpellSlots")
  knownSpells     KnownSpell[]     @relation("CharacterKnownSpells")
  classFeatures   ClassFeature[]   @relation("CharacterClassFeatures")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([userId])
}

model GameSession {
  id              String   @id @default(uuid())
  sessionToken    String   @unique // Pro sdílení

  // User ownership
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  characterId     String
  character       Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  // Game State
  currentLocation String
  questLog        Json     @default("[]") // Array of quests
  worldState      Json     @default("{}") // Custom world variables

  // Conversation History
  messages        Message[]

  // Meta
  isActive        Boolean  @default(true)
  lastPlayedAt    DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([sessionToken])
  @@index([characterId])
  @@index([userId])
  @@index([lastPlayedAt])
}

model Message {
  id            String   @id @default(uuid())

  sessionId     String
  session       GameSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  role          String   // "player", "narrator", "system"
  content       String   @db.Text
  metadata      Json?    // Dice rolls, combat results, etc.

  createdAt     DateTime @default(now())

  @@index([sessionId])
  @@index([createdAt])
}

model Item {
  id          String   @id @default(uuid())

  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  name        String
  type        String   // weapon, armor, potion, accessory, misc
  description String?  @db.Text
  quantity    Int      @default(1)
  equipped    Boolean  @default(false)

  // Stats for weapons/armor
  damage      String?  // "1d8+2"
  armorValue  Int?
  properties  Json?    // Special properties

  // Stat bonuses from magical items
  statBonuses Json?    // { strength: 2, acBonus: 1, hpBonus: 5 }
  rarity      String   @default("common")  // common, uncommon, rare, very_rare, legendary

  // Attunement system (D&D 5e)
  requiresAttunement Boolean @default(false)
  isAttuned   Boolean  @default(false)
  // Pravidlo: Max 3 attuned items per character
  // Bonusy z itemů s requiresAttunement se aplikují pouze pokud isAttuned = true

  createdAt   DateTime @default(now())

  @@index([characterId])
  @@index([equipped])
  @@index([isAttuned])
}

model WorldLocation {
  id          String   @id @default(uuid())
  name        String   @unique
  description String   @db.Text
  type        String   // town, dungeon, wilderness, cave, castle, etc.
  imageUrl    String?

  // Connections
  connectedTo Json     @default("[]") // Array of location IDs

  // NPCs and Encounters
  npcs        Json?
  encounters  Json?

  // Discovery
  discovered  Boolean  @default(false)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([name])
  @@index([type])
}

// ═══════════════════════════════════════════════
// SPELL MANAGEMENT MODELS
// ═══════════════════════════════════════════════

model SpellSlot {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation("CharacterSpellSlots", fields: [characterId], references: [id], onDelete: Cascade)

  level       Int       // 1-9 (spell level)
  maximum     Int       // Maximum počet slotů pro tento level
  current     Int       // Aktuálně dostupné sloty

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([characterId, level])
  @@unique([characterId, level])
}

model KnownSpell {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation("CharacterKnownSpells", fields: [characterId], references: [id], onDelete: Cascade)

  spellName   String
  spellLevel  Int       // 0-9 (0 = cantrip)
  school      String    // evocation, conjuration, abjuration, transmutation, illusion, necromancy, divination, enchantment
  description String    @db.Text

  createdAt   DateTime  @default(now())

  @@index([characterId])
  @@unique([characterId, spellName])
}

model ClassFeature {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation("CharacterClassFeatures", fields: [characterId], references: [id], onDelete: Cascade)

  name        String
  description String    @db.Text
  unlockLevel Int       // Level na kterém se feature odemkne
  usesPerRest Int?      // null = unlimited uses
  currentUses Int?      // Aktuálně dostupné uses

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([characterId])
}

// ═══════════════════════════════════════════════
// GEMINI API USAGE TRACKING
// ═══════════════════════════════════════════════

model GeminiUsage {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  operation   String   // "generateAction", "analyzeAtmosphere", "summarizeConversation", etc.
  timestamp   DateTime @default(now())
  success     Boolean  @default(true)
  errorCode   String?  // "RESOURCE_EXHAUSTED", "INVALID_ARGUMENT", null

  @@index([userId, timestamp])
  @@index([timestamp])
}

// ═══════════════════════════════════════════════
// ADMIN AUDIT LOG
// ═══════════════════════════════════════════════

model AdminAuditLog {
  id          String   @id @default(uuid())
  adminId     String
  admin       User     @relation("AdminActions", fields: [adminId], references: [id], onDelete: Cascade)

  action      String   // "USER_BAN", "USER_DELETE", "USER_UNBAN", "CHARACTER_DELETE", "SESSION_TERMINATE"
  targetType  String   // "user", "character", "session"
  targetId    String
  metadata    Json?    // Důvod, poznámky, další kontext

  timestamp   DateTime @default(now())

  @@index([adminId, timestamp])
  @@index([targetType, targetId])
  @@index([timestamp])
}

// ═══════════════════════════════════════════════
// BUG REPORTING SYSTEM
// ═══════════════════════════════════════════════

model BugReport {
  id          String   @id @default(uuid())

  // Reporter info
  userId      String?  // Null pokud není přihlášený (optional)
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Bug details
  title       String
  description String   @db.Text
  category    String   // "bug", "enhancement", "other"
  severity    String   // "low", "medium", "high", "critical"

  // Context
  url         String?  // URL kde se bug vyskytl
  userAgent   String?  // Browser info
  screenshots Json?    @default("[]")  // Array of screenshot paths

  // Status tracking
  status      String   @default("open") // "open", "in_progress", "resolved", "closed", "wont_fix"
  priority    Int      @default(0)      // 0-4 (admin může upravit)

  // Admin handling
  assignedTo  String?  // Admin user ID
  assignedAdmin User?  @relation("BugReportAssignee", fields: [assignedTo], references: [id], onDelete: SetNull)

  adminNotes  String?  @db.Text
  resolvedAt  DateTime?
  resolvedBy  String?  // Admin user ID
  resolver    User?    @relation("BugReportResolver", fields: [resolvedBy], references: [id], onDelete: SetNull)

  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([category])
  @@index([severity])
  @@index([createdAt])
  @@index([assignedTo])
}
